{"version":3,"file":"FloatingTitlePane.js","sources":["FloatingTitlePane.js"],"names":["define","declare","TitlePane","on","lang","Moveable","aspect","topic","win","winUtils","domGeom","domStyle","domConstruct","domAttr","domClass","sidebarPosition","postCreate","this","canFloat","createDomNodes","own","window","hitch","subscribe","after","inherited","arguments","startup","titleBarNode","_moveable","domNode","delay","handle","document","moveHandleNode","create","title","class","titleNode","dockHandleNode","style","evt","_dockWidget","stopImmediatePropagation","toggle","isFloating","isDragging","remove","set","dockedWidgets","sidebar","getChildren","length","placeAt","_updateTopic","_dragging","_startDrag","mover","titleCursor","get","_checkSidebarPosition","computedStyle","getComputedStyle","containerNode","width","parseInt","setContentSize","w","body","titleHeight","top","marginBox","t","_endDrag","nodePosition","position","viewport","getBox","ownerDocument","y","Math","min","max","h","x","_relativePosition","_position","setTimeout","contains","ownerDocumentBody","node","p","bb","l","floor","left","_updateWidgetSidebarPosition","msg","id","widgetID","pos","action","k","len","widget","publish","category","label","value","_afterToggle","open"],"mappings":"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","sourcesContent":["define([\n    'dojo/_base/declare',\n    'dijit/TitlePane',\n    'dojo/on',\n    'dojo/_base/lang',\n    'dojo/dnd/Moveable',\n    'dojo/aspect',\n    'dojo/topic',\n    'dojo/_base/window',\n    'dojo/window',\n    'dojo/dom-geometry',\n    'dojo/dom-style',\n    'dojo/dom-construct',\n    'dojo/dom-attr',\n    'dojo/dom-class',\n    'xstyle/css!./FloatingTitlePane/css/FloatingTitlePane.css'\n], function (declare, TitlePane, on, lang, Moveable, aspect, topic, win, winUtils, domGeom, domStyle, domConstruct, domAttr, domClass) {\n    return declare([TitlePane], {\n        sidebarPosition: null,\n        postCreate: function () {\n            if (this.canFloat) {\n                this.createDomNodes();\n                this.own(on(window, 'resize', lang.hitch(this, '_endDrag')));\n            }\n            this.own(topic.subscribe('titlePane/event', lang.hitch(this, '_updateWidgetSidebarPosition')));\n            this.own(aspect.after(this, 'toggle', lang.hitch(this, '_afterToggle')));\n            this.inherited(arguments);\n        },\n        startup: function () {\n            if (this.titleBarNode && this.canFloat) {\n                this._moveable = new Moveable(this.domNode, {\n                    delay: 5,\n                    handle: this.titleBarNode\n                });\n                aspect.after(this._moveable, 'onMove', lang.hitch(this, '_dragging'), true);\n                aspect.after(this._moveable, 'onMoveStop', lang.hitch(this, '_endDrag'), true);\n                aspect.after(this._moveable, 'onMoveStart', lang.hitch(this, '_startDrag'), true);\n                \n                // ensure that dragging the movable stops no matter\n                // when/where the mouse is released or a touch is completed\n                on(document, 'mouseup, touchend', lang.hitch(this, '_endDrag'));\n            }\n            this.inherited(arguments);\n        },\n        createDomNodes: function () {\n            this.moveHandleNode = domConstruct.create('span', {\n                title: 'Move widget',\n                'class': 'floatingWidgetPopout'\n            }, this.titleNode, 'after');\n\n            this.dockHandleNode = domConstruct.create('span', {\n                title: 'Dock widget',\n                style: 'display:none',\n                'class': 'floatingWidgetDock'\n            }, this.titleNode, 'after');\n            this.own(on(this.dockHandleNode, 'click', lang.hitch(this, function (evt) {\n                this._dockWidget();\n                evt.stopImmediatePropagation();\n            })));\n        },\n        toggle: function () {\n            if (this.isFloating && this.isDragging) {\n                return;\n            }\n            this.inherited(arguments);\n        },\n        _dockWidget: function () {\n            if (!this.isDragging) {\n                domAttr.remove(this.domNode, 'style');\n                domStyle.set(this.dockHandleNode, 'display', 'none');\n                domStyle.set(this.moveHandleNode, 'display', 'inline');\n                var dockedWidgets = this.sidebar.getChildren();\n                if (this.sidebarPosition > dockedWidgets.length || this.sidebarPosition < 0) {\n                    this.sidebarPosition = dockedWidgets.length;\n                }\n                this.placeAt(this.sidebar, this.sidebarPosition);\n                this.isFloating = false;\n                this._updateTopic('dock');\n            }\n        },\n        _dragging: function () {\n            this.isDragging = true;\n        },\n        _startDrag: function (mover) {\n            if (!this.titleCursor) {\n                this.titleCursor = domStyle.get(this.titleBarNode, 'cursor');\n            }\n            domStyle.set(this.titleBarNode, 'cursor', 'move');\n\n            if (!this.isFloating) {\n                this._checkSidebarPosition();\n                domStyle.set(this.dockHandleNode, 'display', 'inline');\n                domStyle.set(this.moveHandleNode, 'display', 'none');\n                domStyle.set(this.domNode, 'z-index', '40');\n                var computedStyle = domStyle.getComputedStyle(this.containerNode);\n                var width = parseInt(domStyle.getComputedStyle(this.sidebar.containerNode).width, 10);\n                domGeom.setContentSize(this.domNode, {\n                    w: (width - 2)\n                }, computedStyle);\n                this.isFloating = true;\n                this.placeAt(win.body());\n                var titleHeight = domStyle.get(this.titleBarNode, 'height');\n                domStyle.set(this.domNode, {\n                    top: (mover.marginBox.t - titleHeight) + 'px'\n                });\n                this._updateTopic('undock');\n            }\n        },\n        _endDrag: function () {\n            // summary:\n            //      Called after dragging the Dialog. Saves the position of the dialog in the viewport,\n            //      and also adjust position to be fully within the viewport, so user doesn't lose access to handle\n            var nodePosition = domGeom.position(this.domNode);\n            var viewport = winUtils.getBox(this.ownerDocument);\n            nodePosition.y = Math.min(Math.max(nodePosition.y, 0), (viewport.h - nodePosition.h));\n            nodePosition.x = Math.min(Math.max(nodePosition.x, 0), (viewport.w - nodePosition.w));\n            this._relativePosition = nodePosition;\n            this._position();\n            domStyle.set(this.titleBarNode, 'cursor', this.titleCursor);\n\n            //delayed slightly so the titlebar does not toggle\n            window.setTimeout(lang.hitch(this, function () {\n                this.isDragging = false;\n            }), 50);\n        },\n        _position: function () {\n            // summary:\n            //      Position the dialog in the viewport.  If no relative offset\n            //      in the viewport has been determined (by dragging, for instance),\n            //      center the dialog.  Otherwise, use the Dialog's stored relative offset,\n            //      adjusted by the viewport's scroll.\n            if (!domClass.contains(this.ownerDocumentBody, 'dojoMove')) { // don't do anything if called during auto-scroll\n                var node = this.domNode,\n                    viewport = winUtils.getBox(this.ownerDocument),\n                    p = this._relativePosition,\n                    bb = p ? null : domGeom.position(node),\n                    l = Math.floor(viewport.l + (p ? p.x : (viewport.w - bb.w) / 2)),\n                    t = Math.floor(viewport.t + (p ? p.y : (viewport.h - bb.h) / 2));\n                domStyle.set(node, {\n                    left: l + 'px',\n                    top: t + 'px'\n                });\n            }\n        },\n        _updateWidgetSidebarPosition: function (msg) {\n            var id = msg.widgetID, pos = msg.sidebarPosition, action = msg.action;\n\n            // do nothing if the topic is from the same widget\n            // or this widget cannot float\n            // or if the action is not dock/undock\n            if (id === this.id || !this.canFloat || (action !== 'dock' && action !== 'undock')) {\n                return;\n            }\n\n            this._checkSidebarPosition();\n\n            // increment the position if the other widget is docked\n            // above this widget's position\n            if (action === 'dock') {\n                var dockedWidgets = this.sidebar.getChildren();\n                if (pos < this.sidebarPosition && this.sidebarPosition < dockedWidgets.length) {\n                    this.sidebarPosition++;\n                }\n\n            // decrement the position if the other widget is undocked\n            // above this widget's position\n            } else if (action === 'undock') {\n                if (pos < this.sidebarPosition && this.sidebarPosition > 0) {\n                    this.sidebarPosition--;\n                }\n            }\n        },\n        _checkSidebarPosition: function () {\n            // set the initial sidebar positions for all floating\n            // widgets in this same sidebar. This is done\n            // only once when the first widget is undocked.\n            var dockedWidgets = this.sidebar.getChildren();\n            if (this.sidebarPosition === null) {\n                var k = 0, len = dockedWidgets.length;\n                for (k = 0; k < len; k++) {\n                    var widget = dockedWidgets[k];\n                    if (widget.canFloat) {\n                        widget.sidebarPosition = k;\n                    }\n                }\n            }\n        },\n        _updateTopic: function (msg) {\n            topic.publish('titlePane/event', {\n                category: 'Titlepane Event',\n                action: msg,\n                label: this.title,\n                widgetID: this.id,\n                sidebarPosition: this.sidebarPosition,\n                value: msg\n            });\n        },\n        _afterToggle: function () {\n            var evt = this.open ? 'open' : 'close';\n            this._updateTopic(evt);\n        }\n    });\n});"]}